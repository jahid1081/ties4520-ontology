<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML+RDFa 1.1//EN" "http://www.w3.org/MarkUp/DTD/xhtml-rdfa-2.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"
      xml:lang="en"
      version="XHTML+RDFa 1.1"
      prefix="
        rdf:  http://www.w3.org/1999/02/22-rdf-syntax-ns#
        rdfs: http://www.w3.org/2000/01/rdf-schema#
        xsd:  http://www.w3.org/2001/XMLSchema#
        onto: https://jahid1081.github.io/ties4520-ontology/ontology.ttl#
        ind:  https://jahid1081.github.io/ties4520-ontology/individuals.ttl#
      ">
  <head>
  <meta name="series-id" content="Series_Poker_Face"/>
    <title>Poker Face — From TTL</title>
    <meta http-equiv="Content-Type" content="application/xhtml+xml; charset=utf-8" />
    <style type="text/css">
      /* same styles as shows.xhtml, trimmed */
      :root { color-scheme: dark; --bg:#0b0e12; --card:#12161c; --muted:#8aa0b3; --text:#e8eef5; --brand:#6ab0ff; --ring:#213245; }
      html, body { margin:0; padding:0; background:var(--bg); color:var(--text); font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; }
      .wrap { max-width: 1100px; margin:0 auto; padding:16px; }
      .btn { display:inline-flex; align-items:center; gap:8px; padding:10px 14px; border-radius:14px; background:#18202b; border:1px solid #243241; color:var(--text); text-decoration:none; }
      header { position: sticky; top:0; z-index:10; backdrop-filter: blur(8px); background: linear-gradient(180deg, rgba(11,14,18,0.9), rgba(11,14,18,0.6) 70%, rgba(11,14,18,0)); border-bottom: 1px solid #1e2733; }
      .series { background: var(--card); border:1px solid #1a2330; border-radius: 18px; overflow: clip; }
      .series-head { display:grid; grid-template-columns: 220px 1fr; gap: 16px; padding: 16px; border-bottom:1px solid #1a2330; }
      .poster-frame { width: 220px; height: 320px; border-radius: 12px; overflow: hidden; background:#0d1117; border:1px solid #1a2330; display:flex; align-items:center; justify-content:center; }
      .poster-frame img { width:100%; height:100%; object-fit: cover; }
      .series-meta h1 { margin:0 0 8px 0; font-size:28px; }
      .pill { padding:6px 10px; border:1px solid #223144; background:#111620; border-radius: 999px; font-size: 13px; color:#cfe3ff; margin-right:8px; }
      .season { border:1px solid #1a2330; border-radius: 14px; padding: 12px; margin: 14px 0; background:#0f141b; }
      .episodes { display:grid; gap:8px; }
      .ep { display:grid; grid-template-columns: 70px 1fr; gap: 10px; border:1px solid #1a2330; background:#0c1016; padding: 10px; border-radius: 12px; }
      .ep-num { font-weight: 700; color:#9bb9ff; }
      .ep-title { margin:0; font-weight:600; }
      .ep-sub { color:#8aa0b3; font-size:13px; margin-top:2px; }
    </style>
<link rel="stylesheet" href="chips-fix.css"/>

  </head>
  <body typeof="rdf:Bag">
    <header class="wrap">
      <a class="btn" href="index.html">&#8962; Home</a>
      <a class="btn" href="shows.xhtml">All Shows</a>
      <button class="btn" onclick="history.back()">&#8592; Back</button>
    <div id="extra-meta" class="meta-row"></div>
</header>

    <main class="wrap">
      <div id="mount"></div>
    </main>

    <script type="module">
    <![CDATA[
      import "https://unpkg.com/n3@1.17.4/browser/n3.min.js";
      const NS = {
        rdf:"http://www.w3.org/1999/02/22-rdf-syntax-ns#",
        rdfs:"http://www.w3.org/2000/01/rdf-schema#",
        xsd:"http://www.w3.org/2001/XMLSchema#",
        onto:"https://jahid1081.github.io/ties4520-ontology/ontology.ttl#",
        ind:"https://jahid1081.github.io/ties4520-ontology/individuals.ttl#"
      };
      const SERIES_IRI = NS.ind + "Series_Poker_Face";
      const TTL_URLS = [
        "https://jahid1081.github.io/ties4520-ontology/ontology.ttl",
        "https://jahid1081.github.io/ties4520-ontology/individuals.ttl"
      ];
      const { Parser, Store, DataFactory } = window.N3;
      const { namedNode } = DataFactory;

      const el = (t,a={},txt=null)=>{const e=document.createElement(t); for(const k in a)e.setAttribute(k,a[k]); if(txt!==null)e.appendChild(document.createTextNode(txt)); return e;};
      function uniq(a){ return [...new Set(a)]; }
      function label(store, term){ return store.getQuads(term, namedNode(NS.rdfs+"label"), null, null)[0]?.object?.value || term.value; }
      function lit(store, s, p){ return store.getQuads(s, namedNode(p), null, null).map(q=>q.object.value); }
      function objs(store, s, p){ return store.getQuads(s, namedNode(p), null, null).map(q=>q.object); }
      function intProp(store, s, p){ const o = store.getQuads(s, namedNode(p), null, null)[0]?.object; return o? parseInt(o.value,10): null; }

      async function load(){
        const store = new Store();
        for (const u of TTL_URLS){
          const txt = await fetch(u, {cache:"no-store"}).then(r=>r.text());
          store.addQuads(new Parser({format:"text/turtle"}).parse(txt));
        }
        return store;
      }

      function seasons(store, series){
        const viaHas = objs(store, series, NS.onto+"hasSeason");
        const viaPart = store.getQuads(null, namedNode(NS.onto+"partOfSeries"), series, null)
          .filter(q => store.getQuads(q.subject, namedNode(NS.rdf+"type"), namedNode(NS.onto+"Season"), null).length>0)
          .map(q=>q.subject);
        const list = uniq(viaHas.concat(viaPart).map(t=>t.value)).map(v=>namedNode(v));
        return list.filter(s => (intProp(store,s,NS.onto+"seasonNumber")||0) >= 1)
                   .sort((a,b)=> (intProp(store,a,NS.onto+"seasonNumber")||0) - (intProp(store,b,NS.onto+"seasonNumber")||0));
      }

      function episodes(store, season){
        const viaHas = objs(store, season, NS.onto+"hasEpisode");
        const viaIs  = store.getQuads(null, namedNode(NS.onto+"isEpisodeOf"), season, null).map(q=>q.subject);
        const all = uniq(viaHas.concat(viaIs).map(t=>t.value)).map(v=>namedNode(v));
        return all.sort((a,b)=> (intProp(store,a,NS.onto+"episodeNumber")||0) - (intProp(store,b,NS.onto+"episodeNumber")||0));
      }

      function renderSeries(store, s){
        const mount = document.getElementById("mount");
        const card = el("section", { class:"series", about:s.value, typeof:"onto:Series" });

        const head = el("div", { class:"series-head" });
        const poster = el("div", { class:"poster-frame" });
        const purl = lit(store, s, NS.onto+"poster")[0] || "";
        poster.appendChild(el("img", { src:purl, alt: label(store,s)+" poster", property:"onto:poster" }));

        const meta = el("div", { class:"series-meta" });
        const h1 = el("h1", { property:"rdfs:label" }, label(store, s));
        meta.appendChild(h1);

        const pills = [
          ["Language", objs(store,s,NS.onto+"inLanguage").map(t=>label(store,t)).join(", ")],
          ["Rating", objs(store,s,NS.onto+"contentRating").map(t=>label(store,t)).join(", ")],
          ["Showrunner", objs(store,s,NS.onto+"hasShowrunner").map(t=>label(store,t)).join(", ")],
          ["Home", objs(store,s,NS.onto+"hasHomePlatform").map(t=>label(store,t)).join(", ")],
          ["Streams", uniq(objs(store,s,NS.onto+"streamsOn").map(t=>label(store,t))).join(", ")]
        ];
        const pillRow = el("div", {});
        pills.forEach(([k,v])=>{ if (v) pillRow.appendChild(el("span", { class:"pill" }, k+": "+v)); });
        meta.appendChild(pillRow);

        const view = el("a", { class:"btn", href:"viewer.xhtml?subject="+encodeURIComponent(s.value) }, "Open in Viewer");
        meta.appendChild(view);

        head.appendChild(poster);
        head.appendChild(meta);
        card.appendChild(head);

        const body = el("div", { class:"wrap" });
        // availability
        const avs = objs(store, s, NS.onto+"hasAvailability");
        if (avs.length){
          const avRow = el("div", {});
          avs.forEach(a=>{
            const reg = objs(store, a, NS.onto+"region").map(t=>label(store,t))[0] || "Region";
            const plat = objs(store, a, NS.onto+"platform").map(t=>label(store,t))[0] || "Platform";
            avRow.appendChild(el("span", { class:"pill" }, reg+" \u2192 "+plat));
          });
          body.appendChild(avRow);
        }

        // seasons + episodes
        seasons(store, s).forEach(sea=>{
          const sc = el("div", { class:"season", about:sea.value, typeof:"onto:Season" });
          const sn = intProp(store, sea, NS.onto+"seasonNumber") || "";
          sc.appendChild(el("h2", {}, "Season "+sn+" — "+label(store, sea)));
          const epsWrap = el("div", { class:"episodes" });

          episodes(store, sea).forEach(ep=>{
            const eNum = intProp(store, ep, NS.onto+"episodeNumber") || "?";
            const row = el("div", { class:"ep", about:ep.value, typeof:"onto:Episode" });
            row.appendChild(el("div", { class:"ep-num", property:"onto:episodeNumber" }, "#"+eNum));
            const main = el("div", {});
            main.appendChild(el("p", { class:"ep-title", property:"rdfs:label" }, label(store, ep)));
            const air = lit(store, ep, NS.onto+"airDate")[0];
            const drs = objs(store, ep, NS.onto+"hasDirector").map(t=>label(store,t));
            const wrs = objs(store, ep, NS.onto+"hasWriter").map(t=>label(store,t));
            main.appendChild(el("div", { class:"ep-sub" },
              (air? "Air: "+air+" · " : "")+"Dir: "+(drs.length? uniq(drs).join(", "):"—")+" · Writer: "+(wrs.length? uniq(wrs).join(", "):"—")
            ));
            row.appendChild(main);
            epsWrap.appendChild(row);
          });

          sc.appendChild(epsWrap);
          body.appendChild(sc);
        });

        card.appendChild(body);
        mount.appendChild(card);
      }

      (async function(){
        const store = await load();
        renderSeries(store, namedNode(SERIES_IRI));
      })();
    ]]>
    </script>
  
  <script src="https://cdn.jsdelivr.net/npm/n3@1.17.3/browser/n3.min.js"></script>
  <script src="viewer-util.js"></script>
  <script src="series-enhance.js"></script>
      <script src="chips-fix.js"></script>


</body>
</html>
