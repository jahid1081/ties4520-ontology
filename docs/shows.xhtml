<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML+RDFa 1.1//EN" "http://www.w3.org/MarkUp/DTD/xhtml-rdfa-2.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"
      xml:lang="en"
      version="XHTML+RDFa 1.1"
      prefix="
        rdf:  http://www.w3.org/1999/02/22-rdf-syntax-ns#
        rdfs: http://www.w3.org/2000/01/rdf-schema#
        xsd:  http://www.w3.org/2001/XMLSchema#
        onto: https://jahid1081.github.io/ties4520-ontology/ontology.ttl#
        ind:  https://jahid1081.github.io/ties4520-ontology/individuals.ttl#
      ">
  <head>
    <title>All Shows</title>
    <meta http-equiv="Content-Type" content="application/xhtml+xml; charset=utf-8" />
    <style type="text/css">
      :root {
        color-scheme: dark;
        --bg: #0b0e12;
        --card: #12161c;
        --muted: #8aa0b3;
        --text: #e8eef5;
        --brand: #6ab0ff;
        --accent: #9de26a;
        --danger: #ff6a6a;
        --ring: #213245;
      }
      * { box-sizing: border-box; }
      html, body { margin:0; padding:0; background:var(--bg); color:var(--text); font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, "Helvetica Neue", Arial, "Noto Sans", "Liberation Sans", sans-serif; }
      a { color: var(--brand); text-decoration: none; }
      header { position: sticky; top:0; z-index:10; backdrop-filter: blur(8px); background: linear-gradient(180deg, rgba(11,14,18,0.9), rgba(11,14,18,0.6) 70%, rgba(11,14,18,0)); border-bottom: 1px solid #1e2733; }
      .wrap { max-width: 1100px; margin: 0 auto; padding: 16px; }
      .row { display: flex; gap: 10px; flex-wrap: wrap; align-items: center; }
      .btn { display:inline-flex; align-items:center; gap:8px; padding:10px 14px; border-radius:14px; background:#18202b; border:1px solid #243241; color:var(--text); cursor:pointer; transition: .2s transform, .2s background, .2s border-color; }
      .btn:hover { transform: translateY(-1px); background:#1b2633; border-color:#2b3c4f; }
      .btn.primary { background: #1a2a3b; border-color:#2c4157; }
      .grid { display: grid; grid-template-columns: 1fr; gap: 20px; margin-top: 18px; }
      @media (min-width: 880px){ .grid { grid-template-columns: 1fr; } }
      .series { background: var(--card); border:1px solid #1a2330; border-radius: 18px; overflow: clip; }
      .series-head { display:grid; grid-template-columns: 180px 1fr; gap: 16px; padding: 16px; border-bottom:1px solid #1a2330; }
      .poster-frame { width: 180px; height: 260px; border-radius: 12px; overflow: hidden; background: #0d1117; border:1px solid #1a2330; display:flex; align-items:center; justify-content:center; }
      .poster-frame img { width:100%; height:100%; object-fit: cover; }
      .series-meta h2 { margin: 0 0 8px 0; font-size: 24px; }
      .meta-row { display:flex; flex-wrap:wrap; gap:12px; color:var(--muted); }
      .pill { padding:6px 10px; border:1px solid #223144; background:#111620; border-radius: 999px; font-size: 13px; color:#cfe3ff; }
      .actions { margin-top: 10px; display:flex; gap:10px; flex-wrap:wrap; }
      .series-body { padding: 16px; }
      .season { border:1px solid #1a2330; border-radius: 14px; padding: 12px; margin-bottom: 14px; background:#0f141b; }
      .season h3 { margin: 0 0 8px 0; font-size:18px; }
      .episodes { display:grid; gap:8px; }
      .ep { display:grid; grid-template-columns: 70px 1fr; gap: 10px; border:1px solid #1a2330; background:#0c1016; padding: 10px; border-radius: 12px; }
      .ep-num { font-weight: 700; color:#9bb9ff; }
      .ep-title { margin:0; font-weight:600; }
      .ep-sub { color: var(--muted); font-size: 13px; margin-top: 2px; }
      footer { display:none; }
      .section-title { margin: 20px 0 8px 0; font-size: 20px; }
    </style>
  </head>
  <body typeof="rdf:Bag">
    <header>
      <div class="wrap row">
        <button class="btn" onclick="history.back()">&#8592; Back</button>
        <a class="btn primary" href="index.html">Home</a>
        <div style="flex:1"></div>
        <div class="pill">All Shows (from TTL)</div>
      </div>
    </header>

    <main class="wrap">
      <div id="mount" class="grid"></div>
    </main>

    <!-- N3 parser -->
    <script type="module">
    <![CDATA[
      import "https://unpkg.com/n3@1.17.4/browser/n3.min.js";

      const NS = {
        rdf:  "http://www.w3.org/1999/02/22-rdf-syntax-ns#",
        rdfs: "http://www.w3.org/2000/01/rdf-schema#",
        xsd:  "http://www.w3.org/2001/XMLSchema#",
        onto: "https://jahid1081.github.io/ties4520-ontology/ontology.ttl#",
        ind:  "https://jahid1081.github.io/ties4520-ontology/individuals.ttl#"
      };

      const TTL_URLS = [
        "https://jahid1081.github.io/ties4520-ontology/ontology.ttl",
        "https://jahid1081.github.io/ties4520-ontology/individuals.ttl"
      ];

      const { Parser, Store, DataFactory } = window.N3;
      const { namedNode, literal, quad } = DataFactory;

      const $ = (sel, root=document) => root.querySelector(sel);
      const el = (tag, attrs={}, text=null) => {
        const e = document.createElement(tag);
        for (const k in attrs) e.setAttribute(k, attrs[k]);
        if (text!==null) e.appendChild(document.createTextNode(text));
        return e;
      };

      function curie(iri){
        for (const [p, ns] of Object.entries(NS)){
          if (iri.startsWith(ns)) return p + ":" + iri.slice(ns.length);
        }
        return iri;
      }

      function uniq(arr){ return [...new Set(arr.map(x => typeof x==="string" ? x : x.value))]; }
      function byIntProp(store, s, p, fallback=9999){
        const v = store.getQuads(s, namedNode(p), null, null)[0]?.object;
        if (v && v.datatype && v.datatype.value===NS.xsd+"integer") return parseInt(v.value,10);
        if (v) return parseInt(v.value,10) || fallback;
        return fallback;
      }
      function label(store, term){
        const lab = store.getQuads(term, namedNode(NS.rdfs+"label"), null, null)[0]?.object?.value;
        return lab || curie(term.value);
      }
      function lit(store, s, p){
        return store.getQuads(s, namedNode(p), null, null).map(q => q.object.value);
      }
      function objs(store, s, p){
        return store.getQuads(s, namedNode(p), null, null).map(q => q.object);
      }

      async function loadStore(){
        const store = new Store();
        for (const url of TTL_URLS){
          const text = await fetch(url, {cache:"no-store"}).then(r => r.text());
          const parser = new Parser({ format:"text/turtle" });
          store.addQuads(parser.parse(text));
        }
        return store;
      }

      function seriesSubjects(store){
        return uniq(store.getQuads(null, namedNode(NS.rdf+"type"), namedNode(NS.onto+"Series"), null)
                 .map(q => q.subject.value)).map(v=>namedNode(v));
      }

      function seasonOf(store, series){
        const viaHas = store.getQuads(series, namedNode(NS.onto+"hasSeason"), null, null).map(q=>q.object);
        const viaPart = store.getQuads(null, namedNode(NS.onto+"partOfSeries"), series, null)
                              .filter(q => store.getQuads(q.subject, namedNode(NS.rdf+"type"), namedNode(NS.onto+"Season"), null).length>0)
                              .map(q=>q.subject);
        const all = uniq(viaHas.concat(viaPart));
        const nodes = all.map(v=>typeof v==="string" ? namedNode(v): v);
        const filtered = nodes.filter(s => byIntProp(store, s, NS.onto+"seasonNumber", 0) >= 1);
        return filtered.sort((a,b) => byIntProp(store,a,NS.onto+"seasonNumber") - byIntProp(store,b,NS.onto+"seasonNumber"));
      }

      function episodesOf(store, season){
        const viaHas = store.getQuads(season, namedNode(NS.onto+"hasEpisode"), null, null).map(q=>q.object);
        const viaIs   = store.getQuads(null, namedNode(NS.onto+"isEpisodeOf"), season, null).map(q=>q.subject);
        const viaPart = store.getQuads(null, namedNode(NS.onto+"partOfSeries"), null, null)
          .filter(q => store.getQuads(q.subject, namedNode(NS.onto+"isEpisodeOf"), season, null).length>0)
          .map(q=>q.subject);
        const candidates = uniq(viaHas.concat(viaIs).concat(viaPart));
        const nodes = candidates.map(v=>typeof v==="string"? namedNode(v):v);
        return nodes.sort((a,b)=> byIntProp(store,a,NS.onto+"episodeNumber") - byIntProp(store,b,NS.onto+"episodeNumber"));
      }

      function sectionForSeries(store, s){
        const section = el("section", { class:"series", about:s.value, typeof:"onto:Series" });

        // header
        const head = el("div", { class:"series-head" });
        const posterFrame = el("div", { class:"poster-frame" });
        const posterUrl = lit(store, s, NS.onto+"poster")[0] || "";
        const img = el("img", { src: posterUrl, alt: label(store, s) + " poster", property:"onto:poster" });
        posterFrame.appendChild(img);

        const meta = el("div", { class:"series-meta" });
        const h2 = el("h2", { property:"rdfs:label" }, label(store, s));
        const metaRow = el("div", { class:"meta-row" });

        const langs = objs(store, s, NS.onto+"inLanguage").map(t=>label(store,t));
        const rating = objs(store, s, NS.onto+"contentRating").map(t=>label(store,t));
        const runners = objs(store, s, NS.onto+"hasShowrunner").map(t=>label(store,t));
        const home = objs(store, s, NS.onto+"hasHomePlatform").map(t=>label(store,t));
        const streams = objs(store, s, NS.onto+"streamsOn").map(t=>label(store,t));
        const awards = objs(store, s, NS.onto+"hasAward").map(t=>label(store,t));
        const franch = objs(store, s, NS.onto+"partOfFranchise").map(t=>label(store,t));
        const ongoing = lit(store, s, NS.onto+"isOngoing")[0];

        function pill(txt){ const p = el("span", { class:"pill" }, txt); return p; }

        if (langs.length) metaRow.appendChild(pill("Language: "+langs.join(", ")));
        if (rating.length) metaRow.appendChild(pill("Rating: "+rating.join(", ")));
        if (runners.length) metaRow.appendChild(pill("Showrunner: "+uniq(runners).join(", ")));
        if (home.length) metaRow.appendChild(pill("Home: "+home.join(", ")));
        if (streams.length) metaRow.appendChild(pill("Streams: "+uniq(streams).join(", ")));
        if (awards.length) metaRow.appendChild(pill("Awards: "+awards.join("; ")));
        if (franch.length) metaRow.appendChild(pill("Franchise: "+franch.join(", ")));
        if (ongoing) metaRow.appendChild(pill("Ongoing: "+ongoing));

        const actions = el("div", { class:"actions" });
        const viewBtn = el("a", { class:"btn", href: "viewer.xhtml?subject="+encodeURIComponent(s.value) }, "Open in Viewer");
        actions.appendChild(viewBtn);

        meta.appendChild(h2);
        meta.appendChild(metaRow);
        meta.appendChild(actions);

        head.appendChild(posterFrame);
        head.appendChild(meta);
        section.appendChild(head);

        // body
        const body = el("div", { class:"series-body" });

        // Availability
        const avs = objs(store, s, NS.onto+"hasAvailability");
        if (avs.length){
          body.appendChild(el("div", { class:"section-title" }, "Availability"));
          const row = el("div", { class:"meta-row" });
          avs.forEach(a=>{
            const reg = objs(store, a, NS.onto+"region").map(t=>label(store,t))[0] || "Region";
            const plat = objs(store, a, NS.onto+"platform").map(t=>label(store,t))[0] || "Platform";
            row.appendChild(el("span", { class:"pill" }, reg + " \u2192 " + plat));
          });
          body.appendChild(row);
        }

        // Seasons & episodes
        const seasons = seasonOf(store, s);
        seasons.forEach(sea=>{
          const snum = byIntProp(store, sea, NS.onto+"seasonNumber");
          const sh = el("div", { class:"season", about:sea.value, typeof:"onto:Season" });
          sh.appendChild(el("h3", {}, "Season " + snum + (label(store, sea) ? (" — " + label(store, sea)) : "")));
          const epsWrap = el("div", { class:"episodes" });

          const eps = episodesOf(store, sea);
          eps.forEach(ep=>{
            const eNum = byIntProp(store, ep, NS.onto+"episodeNumber");
            const e = el("div", { class:"ep", about: ep.value, typeof:"onto:Episode" });
            const num = el("div", { class:"ep-num", property:"onto:episodeNumber" }, "#" + (isFinite(eNum)? eNum : "?"));
            const main = el("div", {});

            const title = el("p", { class:"ep-title", property:"rdfs:label" }, label(store, ep));
            const air = lit(store, ep, NS.onto+"airDate")[0];
            const drs = objs(store, ep, NS.onto+"hasDirector").map(t=>label(store,t));
            const wrs = objs(store, ep, NS.onto+"hasWriter").map(t=>label(store,t));

            const sub = el("div", { class:"ep-sub" },
              (air ? ("Air: " + air + " · ") : "") +
              (drs.length ? ("Dir: " + uniq(drs).join(", ")) : "Dir: —") +
              " · " +
              (wrs.length ? ("Writer: " + uniq(wrs).join(", ")) : "Writer: —")
            );

            main.appendChild(title);
            main.appendChild(sub);
            e.appendChild(num);
            e.appendChild(main);
            epsWrap.appendChild(e);
          });

          sh.appendChild(epsWrap);
          body.appendChild(sh);
        });

        section.appendChild(body);
        return section;
      }

      (async function main(){
        const mount = document.getElementById("mount");
        try {
          const store = await loadStore();
          const list = seriesSubjects(store);

          // Only include known three shows, but still auto-read from TTL
          const pickOrder = [
            NS.ind+"Series_Poker_Face",
            NS.ind+"Series_The_Bear",
            NS.ind+"Series_The_Boys"
          ];

          const ordered = list.sort((a,b)=> pickOrder.indexOf(a.value) - pickOrder.indexOf(b.value));
          ordered.forEach(s => mount.appendChild(sectionForSeries(store, s)));
        } catch (e){
          const err = el("div", { class:"series" });
          err.appendChild(el("div", { class:"series-body" }, "Error loading TTL: " + e.message));
          mount.appendChild(err);
        }
      })();
    ]]>
    </script>
  </body>
</html>
